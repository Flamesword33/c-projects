/* Recursive-Descent Parser for a grammar
   for simple expressions:

     <expr> ::= <term> {(+ | -) <term>}
     <term> ::= <factor> {(* | /) <factor>}
     <factor> ::= id | int_constant | ( <expr> )

   From Robert W. Sebesta, Concepts of Programming
   Languages, 10e, Chapter 4.

   Works in conjunction with the lexical scanner
   'front.c' from the same chapter, which defines
   the function lex().

   Each function below leaves the next unconsumed token
   in nextToken, and each function assumes on entry that
   it is available in nextToken.
*/

#include <stdio.h>
#include <stdlib.h>
#include "parser.h"
#include "parser.c"

extern int nextToken;  /* from parser.c */
extern FILE *in_fp;

//Set PARSER to 0 to turn it off (and have only lexical analyzer)
#define PARSER 1

/* Function declarations */
void expr();
void term();
void factor();
void error();

/****************************************************/


/* Function expr
   Parses strings in the language generated by the rule:
     <expr> -> <term> {(+ | -) <term>}
*/

void expr() {
  printf("Entering expr()\n");

  /* Parse the first term */

  term();
  /* As long as the next token is + or -, call
     lex to get the next token and parse the
     next term */

  while (nextToken == ADD_OP ||
         nextToken == SUB_OP){
    lex();
    term();
  }
  printf("Leaving expr()\n");
}

/* term
   Parses strings in the language generated by the rule:
     <term> -> <factor> {(* | /) <factor>)
*/
void term() {
  printf("Entering term()\n");

  /* Parse the first factor */
  factor();

  /* As long as the next token is * or /,
     next token and parse the next factor */
  while (nextToken == MULT_OP || nextToken == DIV_OP) {
    lex();
    factor();
  }
  printf("Leaving term()\n");
} /* End of function term */


/* Function factor
   Parses strings in the language generated by the rule:
     <factor> -> id | int_constant | (<expr>)  */

void factor() {
  printf("Entering factor()\n");

  /* Determine which RHS */
  if (nextToken == IDENT || nextToken == INT_LIT)

    /* For the RHS id, just call lex */
    lex();

  /* If the RHS is (<expr>), call lex to pass over the left parenthesis,
     call expr, and check for the right parenthesis */
  else if (nextToken == LEFT_PAREN) {
    lex();
    expr();
    if (nextToken == RIGHT_PAREN)
      lex();
    else
      error();
  }  /* End of else if (nextToken == ...  */
  
  else error(); /* Neither RHS matches */

  printf("Leaving factor()\n");
}

/* Function error
   Prints error message and exits the parse.
   If you want an entire file to be parsed: take out the exit.
   You will then just get the error messages mixed in.
 */

void error(){
    printf("SYNTAX ERROR\n");
    //exit?
    exit(-1);
}


/* main driver */
#if PARSER
int main() {
  
/* open the input data file and process contents */
  if ((in_fp = fopen("parser.in","r")) == NULL)
    fprintf(stderr, "ERROR - cannot open 'parser.in'\n");
  else {
    getChar();
    do {
      lex();
      expr();
    } while (nextToken != EOF_TOKEN);
  }
  return 0;
}
#endif